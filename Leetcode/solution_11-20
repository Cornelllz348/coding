# 11. Container with Most Water **

# Given n non-negative integers a1, a2, ..., an, 
# where each represents a point at coordinate (i, ai).
# n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). 
# Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.
# Notice that you may not slant the container.

def maxArea(height):
    """
    :type height: List[int]
    :rtype: int
    """
    l = 0
    r = len(height) - 1
    a = 0
    # Left and right pointers start at the beginning and end of the height array respectively
    # calculate current area bounded by the left and right pointers
    # if height[left] < height[right] then move left pointer to the right
    # else move right pointer to the left
    while l < r:
        a = max(a, min(height[l], height[r]) * (r - l))
        if height[l] < height[r]:
            l = l + 1
        else:
            r = r - 1
    return a

# Method: array, two pointers
# Time: O(n)
# Space: O(1)

-----

# 12. Integer to Roman **

# Given an integer, convert it to a roman numeral.

def intToRoman(num):
    """
    :type num: int
    :rtype: str
    """
    result = ""
    base = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    roman = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
    index = [0] * 13
    b = num
    for i in range(len(base)):
        a, b = divmod(b, base[i])
        index[i] = a
    # print(index)
    for i in range(len(roman)):
        result = result + ''.join(roman[i]*index[i])
    return result
    
-----

# 13. Roman to Integer *

# Given a roman numeral, convert it to an integer
# I can be placed before V (5) and X (10) to make 4 and 9. 
# X can be placed before L (50) and C (100) to make 40 and 90. 
# C can be placed before D (500) and M (1000) to make 400 and 900.

def romanToInt(s):
    i = result = 0
    M = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    N = {'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900}
    while i < len(s) - 1:
        if (N.get(s[i:i+2]) == None):
            result = result + M.get(s[i])
            i = i + 1
        else:
            result = result + N.get(s[i:i+2])
            i = i + 2
    if i == len(s) - 1:
        result = result + M.get(s[i])
    return result

-----

# 14. Longest Common Prefix *

# Write a function to find the longest common prefix string amongst an array of strings.
# If there is no common prefix, return an empty string "".

def longestCommonPrefix(strs):
    """
    :type strs: List[str]
    :rtype: str
    """
    if strs == None or len(strs) == 0:
        return ""
    for i in range(len(strs[0])):
        # c is the ith char of the first string in the array
        c = strs[0][i]
        # iterate through the remaining strings in the array
        for j in range(1, len(strs)):
            # if i hits the shortest string or char doesn't match, return the prefix
            if (i == len(strs[j]) or strs[j][i] != c):
                return strs[0][0:i]
    return strs[0]

# Method: String
# Time: O(S) where S is sum of all chars in all strings
# Space: O(1)

-----

# 15. 3 Sum **

# Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? 
# Find all unique triplets in the array which gives the sum of zero.
# Notice that the solution set must not contain duplicate triplets.

def threeSum(nums):
    """
    :type nums: List[int]
    :rtype: List[List[int]]
    """
    res = []
    # first sort the array from smallest to largest
    nums.sort()
    for i in range(len(nums)-2):
        # deduplicate i
        if i > 0 and nums[i] == nums[i-1]:
            continue
        # fix i, let l and r be the left-most and right-most index of the subarray after i
        # calculate 3 sum, if >0, move r to the left (nums[r] needs to be smaller), if <0, move l to the right
        l, r = i+1, len(nums)-1
        while l < r:
            s = nums[i] + nums[l] + nums[r]
            if s < 0:
                l += 1 
            elif s > 0:
                r -= 1
            else:
                res.append((nums[i], nums[l], nums[r]))
                # deduplicate l and r
                while l < r and nums[l] == nums[l+1]:
                    l += 1
                while l < r and nums[r] == nums[r-1]:
                    r -= 1
                l += 1; r -= 1
    return res

"""
     i   l        r<--r
-4  -1  -1  0  1  2  3
"""

# Method: Two pointers
# Time: O(n^2)
# Space: O(n) from sorting
