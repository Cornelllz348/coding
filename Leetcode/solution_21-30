# 21. Merge Two Sorted Lists *

# Merge two sorted linked lists and return it as a new sorted list. 
# The new list should be made by splicing together the nodes of the first two lists.

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
def mergeTwoLists(l1, l2):
    """
    :type l1: ListNode
    :type l2: ListNode
    :rtype: ListNode
    """
    p1 = l1
    p2 = l2
    l3 = ListNode(0)
    dummy = l3
    while p1 and p2:
        # move whichever is smaller
        if p1.val > p2.val:
            dummy.next = p2
            p2 = p2.next
        else:
            dummy.next = p1
            p1 = p1.next
        dummy = dummy.next
    dummy.next = p1 if p1 is not None else p2
    return l3.next

# Method: Linked List
# Time: O(L1 + L2) where L1 and L2 are the length of linked list 1 and 2
# Space: O(L1 + L2)

-----

# 22. Generate Parentheses **

# Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

# Input: n = 3
# Output: ["((()))","(()())","(())()","()(())","()()()"]

def generateParentheses(n):
    ans = []
    def backtrack(S = "", left = 0, right = 0):
        # Let S is string where number of "(" is >= number of ")"
        # Let left track the number of "(" and right track the number of ")"
        # if len(S) is 2*n, stop running as all parentheses have been used up
        if len(S) == 2*n:
            ans.append(S)
            return
        # 1. add "(" if there is still "(" left
        if left < n:
            backtrack(S + "(", left+1, right)
        # 2. add ")" only if the number of "(" is greater than the number of ")"
        if right < left:
            backtrack(S + ")", left, right+1)

    backtrack("", 0, 0)
    return ans

# Method: String, Backtracking
# Time: O(1/(n+1) * C(n, 2n)) - the n-th Catalan number
# Space: O(1/(n+1) * C(n, 2n))

"""
n-th Catalan number:
* given a list of 1 and -1, such that the sum of any leading sub-array is non-negative
* step 1: without considering order of 1 and -1, we have a total of C(n, 2n) combinations
* step 2: this includes C(n-1, 2n) ILLEGAL orders; each ILLEGAL order corresponds to an order of n+1
          1's and n-1 -1's
* step 3: C(n, 2n) - C(n-1, 2n) = 1/(n+1) * C(n,2n)

"""

-----

# 26. Remove Duplicates from Sorted Array *

# Given a sorted array nums, remove the duplicates in-place such that each element appears only once
# and returns the new length.
# Do not allocate extra space for another array, you must do this by modifying the input array in-place 
# with O(1) extra memory.

def removeDuplicates(nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    x = 1
    for i in range(len(nums)-1):
        if(nums[i] != nums[i+1]):
            nums[x] = nums[i+1]
            x = x + 1
    return x
    
-----

# 27. Remove Element *

# Given an array nums and a value val, remove all instances of that value in-place and return the new length.
# Do not allocate extra space for another array, you must do this by modifying the input array in-place
# with O(1) extra memory.
# The order of elements can be changed. It doesn't matter what you leave beyond the new length.

def removeElement(nums, val):
    i = 0
    for j in range(len(nums)):
        if nums[j] != val:
            nums[i] = nums[j]
            i = i + 1
    return i
    
-----

# 28. Implement strStr() *

# Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
# What should we return when needle is an empty string? This is a great question to ask during an interview.
# For the purpose of this problem, we will return 0 when needle is an empty string. 
# This is consistent to C's strstr() and Java's indexOf().

def strStr(haystack, needle):
    """
    :type haystack: str
    :type needle: str
    :rtype: int
    """
    if needle == "":
        return 0
    if len(needle) > len(haystack):
        return -1
    for i in range(len(haystack) - len(needle) + 1):
        if haystack[i:i+len(needle)] == needle:
            return i
    return -1
    
-----

